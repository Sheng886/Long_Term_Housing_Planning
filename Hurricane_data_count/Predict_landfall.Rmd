---
title: "Regression"
output: html_document
date: "2022-09-22"
---

## Package

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(zoo)
library(dplyr)
library(ggplot2) 
library(maps)
library(sp)
library(maptools)
library(geosphere)
library(MASS)
library(viridis)
library(rstan)
library(readr)
library(bayesplot)
library(tidyr)
library(loo)
library(forecast)
library(rugarch)
library(tseries)
library(tscount)
library(mgcv)
library(reshape2)
```

```{r}
# Set a seed for reproducibility
set.seed(123)

# Load data from a CSV file
landfall_data <- read_csv("data_counts/landfall_dat.csv")
```
```{r}
landfall_data$color <- ifelse(landfall_data$x > -81.5, "red", "blue")

# Get US map data
us_map <- map_data("state")

# Plot the US map with hurricane landfall locations colored by condition
ggplot() +
  # Add the US map
  geom_polygon(data = us_map, aes(x = long, y = lat, group = group), 
               fill = "lightgray", color = "black") +
  # Add hurricane landfall points with conditional colors
  geom_point(data = landfall_data, aes(x = x, y = y, color = color), 
             size = 2, alpha = 0.7) +
  scale_color_identity() + # Use the specified colors directly
  labs(title = "Hurricane Landfall Locations by Longitude",
       x = "Longitude",
       y = "Latitude") +
  theme_minimal()
```
```{r}
# Separate into two data frames based on longitude condition
df_Atlantic <- subset(landfall_data, x > -81.5)  # Longitude > -81.5
df_Gulf <- subset(landfall_data, x <= -81.5)  # Longitude <= -81.5

write.csv(df_Atlantic,"A.csv")
write.csv(df_Gulf,"G.csv")

```



```{r}
# Load datasets
data_g <- read.csv("G.csv")
data_a <- read.csv("A.csv")

# Count number of landfalls per year
count_g <- data_g %>% group_by(Year) %>% summarise(Count_G = n())
count_a <- data_a %>% group_by(Year) %>% summarise(Count_A = n())

# Fill missing years
all_years <- data.frame(Year = seq(min(c(count_g$Year, count_a$Year)), 
                                   max(c(count_g$Year, count_a$Year)), 
                                   by = 1))

count_g <- full_join(all_years, count_g, by = "Year") %>% replace_na(list(Count_G = 0))
count_a <- full_join(all_years, count_a, by = "Year") %>% replace_na(list(Count_A = 0))

write.csv(count_g,"g_count.csv")
write.csv(count_a,"a_count.csv")

combined_data <- full_join(count_g, count_a, by = "Year")

```

```{r}
# Plot for Count_G
plot(combined_data$Year, combined_data$Count_G, type = "o", col = "blue",
     xlab = "Year", ylab = "Number of Landfalls", main = "Hurricane Landfall Counts (File G)")



# Plot for Count_A
plot(combined_data$Year, combined_data$Count_A, type = "o", col = "red",
     xlab = "Year", ylab = "Number of Landfalls", main = "Hurricane Landfall Counts (File A)")

```

```{r}
# Decompose Count_G
ts_g <- ts(combined_data$Count_G, start = min(combined_data$Year), frequency = 1)
adf_test <- adf.test(ts_g)
print(adf_test)

# Decompose Count_A
ts_a <- ts(combined_data$Count_A, start = min(combined_data$Year), frequency = 1)
adf_test <- adf.test(ts_a)
print(adf_test)

#ts_g <- diff(ts_g)
#plot(ts_g_diff, main = "Differenced Frequency Time Series", ylab = "Differenced Frequency", xlab = "Year")
#adf.test(ts_g_diff)


#ts_a <- diff(ts_a)
#plot(ts_a_diff, main = "Differenced Frequency Time Series", ylab = "Differenced Frequency", xlab = "Year")
#adf.test(ts_a_diff)


```
```{r}
# 擬合 Poisson 自回歸模型 ( Poisson 自回歸模型)
g_model <- tsglm(ts_g, model = list(past_obs = 1, past_mean = 1), distr = "poisson")
a_model <- tsglm(ts_a, model = list(past_obs = 1, past_mean = 1), distr = "poisson")

summary(g_model)
summary(a_model)

g_poisson_forecast <- predict(g_model, n.ahead = 10)
a_poisson_forecast <- predict(a_model, n.ahead = 10)

plot(g_poisson_forecast$pred, type = "b", main = "Poisson Model Forecast (G)", ylab = "Counts", xlab = "Year")
plot(a_poisson_forecast$pred, type = "b", main = "Poisson Model Forecast (A)", ylab = "Counts", xlab = "Year")


# 繪製殘差圖
pearson_residuals <- residuals(g_model, type = "pearson")
plot(pearson_residuals, type = "o", main = "Pearson Residuals", ylab = "Residuals", xlab = "Time")
abline(h = 0, col = "red")
acf(pearson_residuals, main = "ACF of Residuals")
plot(residuals(g_model), type = "o", main = "Residuals Plot (File G)", ylab = "Residuals", xlab = "Time")
Box.test(residuals(g_model), lag = 10, type = "Ljung-Box")



# 繪製殘差圖
pearson_residuals <- residuals(a_model, type = "pearson")
plot(pearson_residuals, type = "o", main = "Pearson Residuals", ylab = "Residuals", xlab = "Time")
abline(h = 0, col = "red")
acf(pearson_residuals, main = "ACF of Residuals")
plot(residuals(a_model), type = "o", main = "Residuals Plot (File A)", ylab = "Residuals", xlab = "Time")
Box.test(residuals(a_model), lag = 10, type = "Ljung-Box")

```

```{r}

# 負二項分佈模型
g_nb_model <- tsglm(ts_g, model = list(past_obs = 1, past_mean = 1), distr = "nbinom")
a_nb_model <- tsglm(ts_a, model = list(past_obs = 1, past_mean = 1), distr = "nbinom")

summary(g_nb_model)
summary(a_nb_model)

g_poisson_forecast <- predict(g_nb_model, n.ahead = 10)
a_poisson_forecast <- predict(a_nb_model, n.ahead = 10)


plot(g_poisson_forecast$pred, type = "b", main = "Poisson Model Forecast (G)", ylab = "Counts", xlab = "Year")
plot(a_poisson_forecast$pred, type = "b", main = "Poisson Model Forecast (A)", ylab = "Counts", xlab = "Year")

# 繪製殘差圖
pearson_residuals <- residuals(g_nb_model, type = "pearson")
plot(pearson_residuals, type = "o", main = "Pearson Residuals", ylab = "Residuals", xlab = "Time")
abline(h = 0, col = "red")
acf(pearson_residuals, main = "ACF of Residuals")
plot(residuals(g_nb_model), type = "o", main = "Residuals Plot (File G)", ylab = "Residuals", xlab = "Time")
Box.test(residuals(g_nb_model), lag = 10, type = "Ljung-Box")


# 繪製殘差圖
pearson_residuals <- residuals(a_nb_model, type = "pearson")
plot(pearson_residuals, type = "o", main = "Pearson Residuals", ylab = "Residuals", xlab = "Time")
abline(h = 0, col = "red")
acf(pearson_residuals, main = "ACF of Residuals")
plot(residuals(a_nb_model), type = "o", main = "Residuals Plot (File A)", ylab = "Residuals", xlab = "Time")
Box.test(residuals(a_nb_model), lag = 10, type = "Ljung-Box")

```

```{r}
g_data <- read.csv("g_count.csv")  # 替換為文件路徑
a_data <- read.csv("a_count.csv")


# 適合 Poisson 分佈的 GAM 模型
gam_model_g <- gam(Count_G ~ s(Year), family = poisson, data = g_data)
gam_model_a <- gam(Count_A ~ s(Year), family = poisson, data = a_data)

# 模型摘要
summary(gam_model_g)
summary(gam_model_a)

# 殘差檢查
par(mfrow = c(2, 2))
gam.check(gam_model_g)
gam.check(gam_model_a)

# File G 的平滑曲線
plot(gam_model_g, main = "GAM Smooth Plot (File G)", shade = TRUE)

# File A 的平滑曲線
plot(gam_model_a, main = "GAM Smooth Plot (File A)", shade = TRUE)

# 實際值 vs 擬合值
g_data$fitted <- predict(gam_model_g, type = "response")
a_data$fitted <- predict(gam_model_a, type = "response")

ggplot(g_data, aes(x = Year)) +
  geom_point(aes(y = Count_G), color = "blue", size = 2) +
  geom_line(aes(y = fitted), color = "red") +
  ggtitle("Actual vs Fitted (File G)") +
  ylab("Counts") + xlab("Year")

ggplot(a_data, aes(x = Year)) +
  geom_point(aes(y = Count_A), color = "blue", size = 2) +
  geom_line(aes(y = fitted), color = "red") +
  ggtitle("Actual vs Fitted (File A)") +
  ylab("Counts") + xlab("Year")

# 預測未來 10 年的數據
future_years <- data.frame(Year = seq(max(g_data$Year) + 1, max(g_data$Year) + 10))
future_years$fitted_g <- predict(gam_model_g, newdata = future_years, type = "response")
future_years$fitted_a <- predict(gam_model_a, newdata = future_years, type = "response")


# File G 的預測
ggplot() +
  geom_line(data = g_data, aes(x = Year, y = Count_G), color = "blue") +
  geom_line(data = future_years, aes(x = Year, y = fitted_g), color = "red", linetype = "dashed") +
  ggtitle("GAM Forecast (File G)") +
  ylab("Counts") + xlab("Year")

# File A 的預測
ggplot() +
  geom_line(data = a_data, aes(x = Year, y = Count_A), color = "blue") +
  geom_line(data = future_years, aes(x = Year, y = fitted_a), color = "red", linetype = "dashed") +
  ggtitle("GAM Forecast (File A)") +
  ylab("Counts") + xlab("Year")
```
```{r}
# Poisson 自回歸模型 AIC
aic_poisson_g <- AIC(g_model)
aic_poisson_a <- AIC(a_model)

cat("AIC for Poisson model (File G):", aic_poisson_g, "\n")
cat("AIC for Poisson model (File A):", aic_poisson_a, "\n")


# GAM 模型 AIC
aic_gam_g <- AIC(gam_model_g)
aic_gam_a <- AIC(gam_model_a)

cat("AIC for GAM model (File G):", aic_gam_g, "\n")
cat("AIC for GAM model (File A):", aic_gam_a, "\n")

```
```{r}
# 計算均值和變異數
g_mean <- mean(g_data$Count_G)
g_var <- var(g_data$Count_G)

a_mean <- mean(a_data$Count_A)
a_var <- var(a_data$Count_A)

cat("File G - Mean:", g_mean, ", Variance:", g_var, "\n")
cat("File A - Mean:", a_mean, ", Variance:", a_var, "\n")

# 判斷是否過度離散
if (g_var > g_mean) cat("File G: Overdispersion detected.\n")
if (a_var > a_mean) cat("File A: Overdispersion detected.\n")

# File G 的模型
gam_nb_g <- gam(Count_G ~ s(Year), family = nb, data = g_data)

# File A 的模型
gam_nb_a <- gam(Count_A ~ s(Year), family = nb, data = a_data)

# 模型摘要
summary(gam_nb_g)
summary(gam_nb_a)

# 殘差檢查
par(mfrow = c(2, 2))
gam.check(gam_nb_g)
gam.check(gam_nb_a)

# 殘差自相關性檢查
acf(residuals(gam_nb_g), main = "Residuals ACF (File G)")
acf(residuals(gam_nb_a), main = "Residuals ACF (File A)")

# File G 的平滑曲線
plot(gam_nb_g, shade = TRUE, main = "GAM with Negative Binomial (File G)")

# File A 的平滑曲線
plot(gam_nb_a, shade = TRUE, main = "GAM with Negative Binomial (File A)")

# File G
g_data$fitted_nb <- predict(gam_nb_g, type = "response")
ggplot(g_data, aes(x = Year)) +
  geom_point(aes(y = Count_G), color = "blue", size = 2) +
  geom_line(aes(y = fitted_nb), color = "red") +
  ggtitle("Actual vs Fitted (GAM with NB - File G)") +
  ylab("Counts") + xlab("Year")

# File A
a_data$fitted_nb <- predict(gam_nb_a, type = "response")
ggplot(a_data, aes(x = Year)) +
  geom_point(aes(y = Count_A), color = "blue", size = 2) +
  geom_line(aes(y = fitted_nb), color = "red") +
  ggtitle("Actual vs Fitted (GAM with NB - File A)") +
  ylab("Counts") + xlab("Year")

# AIC 比較
aic_nb_g <- AIC(gam_nb_g)
aic_nb_a <- AIC(gam_nb_a)

cat("AIC for GAM with Negative Binomial (File G):", aic_nb_g, "\n")
cat("AIC for GAM with Negative Binomial (File A):", aic_nb_a, "\n")

```


---------------------------------------------------------------------

```{r}

#gam_model_g 
#gam_model_a 

# 預測未來值（假設預測 10 年）
future_years <- data.frame(Year = seq(max(g_data$Year) + 1, max(g_data$Year) + 30))
predictions <- predict(gam_model_g, newdata = future_years, type = "response", se.fit = TRUE)

# 檢查預測結果
predictions_df <- data.frame(Year = future_years$Year,Predicted = predictions$fit,SE = predictions$se.fit)
print(predictions_df)

# 設定樣本數量
set.seed(123)  # 確保可重現
# 設定樣本數量
n_samples <- 10000  # 每年生成 10,000 個樣本

# 為每個未來年份生成樣本，考慮 SE
sampled_data <- lapply(1:nrow(predictions_df), function(i) {
  # 考慮 SE 模擬均值（正態分佈）
  lambda_samples <- rnorm(n_samples, mean = predictions_df$Predicted[i], sd = predictions_df$SE[i])
  
  # 確保均值非負
  lambda_samples[lambda_samples < 0] <- 0
  
  # 從 Poisson 分佈生成樣本
  rpois(n_samples, lambda = lambda_samples)
})

# 將樣本轉為長格式數據框
sample_paths_df <- data.frame(
  Year = rep(predictions_df$Year, each = n_samples),
  Path = rep(1:n_samples, times = nrow(predictions_df)),
  Counts = unlist(sampled_data)
)

sample_paths_df$Category <- cut(
  sample_paths_df$Counts,
  breaks = c(-Inf, 2, 5, Inf),
  labels = c(0, 1, 2),  # 類別：0, 1, 2
  right = TRUE           # 包含上限
)


ggplot(sample_paths_df, aes(x = Year, y = Counts, group = Path)) +
  geom_line(color = "blue") +  # 設置透明度和顏色
  labs(title = "All Sample Paths from GAM Predictions (Same Color)",
       x = "Year", y = "Hurricane Counts") +
  theme_minimal()

category_summary <- table(sample_paths_df$Category)
print(category_summary)

# 可視化類別分佈
ggplot(sample_paths_df, aes(x = Year, y = Category, group = Path)) +
  geom_line(color = "blue") +
  labs(title = "Category Distribution",
       x = "Category", y = "Count") +
  theme_minimal()

# 計算每年的類別
sample_paths_df$Category <- as.numeric(sample_paths_df$Category)  # 確保類別是數值類型

# 確保數據按年份排序
sample_paths_df <- sample_paths_df %>%
  arrange(Path, Year)

# 計算每條路徑的轉移次數
transitions <- sample_paths_df %>%
  group_by(Path) %>%
  mutate(Next_Category = lead(Category, 1)) %>%  # 獲取下一年的類別
  filter(!is.na(Next_Category))                 # 移除最後一年的 NA 轉移

# 獲取所有年份的轉移矩陣
transition_matrix <- transitions %>%
  group_by(Category, Next_Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(Category) %>%
  mutate(Transition_Prob = Count / sum(Count))

# 查看轉移概率矩陣
print(transition_matrix)

# 計算每年的轉移概率
yearly_transitions <- transitions %>%
  group_by(Year, Category, Next_Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(Year, Category) %>%
  mutate(Transition_Prob = Count / sum(Count))

# 查看逐年的轉移概率
print(yearly_transitions)

transition_matrix_wide <- transition_matrix %>%
  pivot_wider(names_from = Next_Category, values_from = Transition_Prob, values_fill = 0)

print(transition_matrix_wide)

# 繪製轉移概率熱力圖
ggplot(transition_matrix, aes(x = Category, y = Next_Category, fill = Transition_Prob)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "blue") +
  labs(title = "Transition Probability Matrix",
       x = "Current Category", y = "Next Category", fill = "Probability") +
  theme_minimal()

ggplot(yearly_transitions, aes(x = Category, y = Next_Category, fill = Transition_Prob)) +
  geom_tile() +
  facet_wrap(~Year) +
  scale_fill_gradient(low = "white", high = "blue") +
  labs(title = "Yearly Transition Probability",
       x = "Current Category", y = "Next Category", fill = "Probability") +
  theme_minimal()

write.csv(yearly_transitions,"trans_G_30.csv")

```

```{r}

#gam_model_g 
#gam_model_a 

# 預測未來值（假設預測 10 年）
future_years <- data.frame(Year = seq(max(g_data$Year) + 1, max(g_data$Year) + 30))
predictions <- predict(gam_model_a, newdata = future_years, type = "response", se.fit = TRUE)

# 檢查預測結果
predictions_df <- data.frame(Year = future_years$Year,Predicted = predictions$fit,SE = predictions$se.fit)
print(predictions_df)

# 設定樣本數量
set.seed(123)  # 確保可重現
# 設定樣本數量
n_samples <- 10000  # 每年生成 10,000 個樣本

# 為每個未來年份生成樣本，考慮 SE
sampled_data <- lapply(1:nrow(predictions_df), function(i) {
  # 考慮 SE 模擬均值（正態分佈）
  lambda_samples <- rnorm(n_samples, mean = predictions_df$Predicted[i], sd = predictions_df$SE[i])
  
  # 確保均值非負
  lambda_samples[lambda_samples < 0] <- 0
  
  # 從 Poisson 分佈生成樣本
  rpois(n_samples, lambda = lambda_samples)
})

# 將樣本轉為長格式數據框
sample_paths_df <- data.frame(
  Year = rep(predictions_df$Year, each = n_samples),
  Path = rep(1:n_samples, times = nrow(predictions_df)),
  Counts = unlist(sampled_data)
)

sample_paths_df$Category <- cut(
  sample_paths_df$Counts,
  breaks = c(-Inf, 2, Inf),
  labels = c(0, 1),  # 類別：0, 1, 2
  right = TRUE           # 包含上限
)


ggplot(sample_paths_df, aes(x = Year, y = Counts, group = Path)) +
  geom_line(color = "blue") +  # 設置透明度和顏色
  labs(title = "All Sample Paths from GAM Predictions (Same Color)",
       x = "Year", y = "Hurricane Counts") +
  theme_minimal()

category_summary <- table(sample_paths_df$Category)
print(category_summary)

# 可視化類別分佈
ggplot(sample_paths_df, aes(x = Year, y = Category, group = Path)) +
  geom_line(color = "blue") +
  labs(title = "Category Distribution",
       x = "Category", y = "Count") +
  theme_minimal()

# 計算每年的類別
sample_paths_df$Category <- as.numeric(sample_paths_df$Category)  # 確保類別是數值類型

# 確保數據按年份排序
sample_paths_df <- sample_paths_df %>%
  arrange(Path, Year)

# 計算每條路徑的轉移次數
transitions <- sample_paths_df %>%
  group_by(Path) %>%
  mutate(Next_Category = lead(Category, 1)) %>%  # 獲取下一年的類別
  filter(!is.na(Next_Category))                 # 移除最後一年的 NA 轉移

# 獲取所有年份的轉移矩陣
transition_matrix <- transitions %>%
  group_by(Category, Next_Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(Category) %>%
  mutate(Transition_Prob = Count / sum(Count))

# 查看轉移概率矩陣
print(transition_matrix)

# 計算每年的轉移概率
yearly_transitions <- transitions %>%
  group_by(Year, Category, Next_Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(Year, Category) %>%
  mutate(Transition_Prob = Count / sum(Count))

# 查看逐年的轉移概率
print(yearly_transitions)

transition_matrix_wide <- transition_matrix %>%
  pivot_wider(names_from = Next_Category, values_from = Transition_Prob, values_fill = 0)

print(transition_matrix_wide)

# 繪製轉移概率熱力圖
ggplot(transition_matrix, aes(x = Category, y = Next_Category, fill = Transition_Prob)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "blue") +
  labs(title = "Transition Probability Matrix",
       x = "Current Category", y = "Next Category", fill = "Probability") +
  theme_minimal()

ggplot(yearly_transitions, aes(x = Category, y = Next_Category, fill = Transition_Prob)) +
  geom_tile() +
  facet_wrap(~Year) +
  scale_fill_gradient(low = "white", high = "blue") +
  labs(title = "Yearly Transition Probability",
       x = "Current Category", y = "Next Category", fill = "Probability") +
  theme_minimal()

write.csv(yearly_transitions,"trans_A_30.csv")


```

```{r}
# Fit SARIMA for Count_G
sarima_g <- Arima(ts_g, order = c(1, 1, 1), seasonal = c(1, 0, 1))
summary(sarima_g)

# Fit SARIMA for Count_A
sarima_a <- Arima(ts_a, order = c(1, 1, 1), seasonal = c(1, 0, 1))
summary(sarima_a)
```

```{r}

spec_g <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
                     mean.model = list(armaOrder = c(1, 1)))
garch_g <- ugarchfit(spec = spec_g, data = ts_g)
print(garch_g)

spec_a <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
                     mean.model = list(armaOrder = c(1, 1)))
garch_a <- ugarchfit(spec = spec_a, data = ts_a)
print(garch_a)


```
```{r}
# Ensure correct usage of AIC and information criteria
arima_g_aic <- as.numeric(AIC(arima_g))
sarima_g_aic <- as.numeric(AIC(sarima_g))
garch_g_aic <- as.numeric(infocriteria(garch_g)["Akaike",])

arima_a_aic <- as.numeric(AIC(arima_a))
sarima_a_aic <- as.numeric(AIC(sarima_a))
garch_a_aic <- as.numeric(infocriteria(garch_a)["Akaike",])

# Combine results into a data frame
model_comparison <- data.frame(
  Model = c("ARIMA (G)", "SARIMA (G)", "GARCH (G)", "ARIMA (A)", "SARIMA (A)", "GARCH (A)"),
  AIC = c(arima_g_aic, sarima_g_aic, garch_g_aic, arima_a_aic, sarima_a_aic, garch_a_aic)
)

# Sort by AIC to identify the best model
model_comparison <- model_comparison[order(model_comparison$AIC), ]
print(model_comparison)
```
```{r}
# Gulf
steps = 1000
sample_num = 100


# Sample 10,000 observations from the GARCH model for Count_G
garch_g_sim <- ugarchsim(garch_g, n.sim = steps, m.sim=sample_num)
garch_g_path <- fitted(garch_g_sim)

reconstructed_forecasts <- list()

for (i in 1:sample_num) {
  predicted_values <- as.numeric(garch_g_path[, i])
  predicted_values[predicted_values < 0] <- 0
  reconstructed_forecasts[[i]] <- predicted_values
}

x_range <- c(1, length(ts_g) + steps)
y_range <- range(c(ts_g, unlist(reconstructed_forecasts)))

plot(ts_g, type = "l", col = "blue", lwd = 2,
     xlim = x_range, ylim = y_range,
     xlab = "Time", ylab = "Value", main = "Original Data and Reconstructed Sample Paths (n.sim = 10)")

for (i in 1:sample_num) {
  start_time <- length(ts_g) + 1
  time_index <- seq(start_time, start_time + length(reconstructed_forecasts[[i]]) - 1)
  lines(time_index, reconstructed_forecasts[[i]], col = "blue", lwd = 1)
}

time_index <- seq(1, length(ts_g))
lines(time_index, ts_g, col = "black")

legend("topright", legend = c("Original Data", "Reconstructed Forecast Paths"), 
       col = c("black", "blue"), lty = 1, lwd = c(2, 1))

# ----------------------------------------------------------

# Sample 10,000 observations from the GARCH model for Count_G
garch_a_sim <- ugarchsim(garch_a, n.sim = steps, m.sim=sample_num)
garch_a_path <- fitted(garch_a_sim)

reconstructed_forecasts <- list()

for (i in 1:sample_num) {
  predicted_values <- as.numeric(garch_a_path[, i])
  predicted_values[predicted_values < 0] <- 0
  reconstructed_forecasts[[i]] <- predicted_values
}

x_range <- c(1, length(ts_a) + steps)
y_range <- range(c(ts_a, unlist(reconstructed_forecasts)))

plot(ts_a, type = "l", col = "blue", lwd = 2,
     xlim = x_range, ylim = y_range,
     xlab = "Time", ylab = "Value", main = "Original Data and Reconstructed Sample Paths (n.sim = 10)")

for (i in 1:sample_num) {
  start_time <- length(ts_a) + 1
  time_index <- seq(start_time, start_time + length(reconstructed_forecasts[[i]]) - 1)
  lines(time_index, reconstructed_forecasts[[i]], col = "blue", lwd = 1)
}

time_index <- seq(1, length(ts_a))
lines(time_index, ts_g, col = "black")

legend("topright", legend = c("Original Data", "Reconstructed Forecast Paths"), 
       col = c("black", "blue"), lty = 1, lwd = c(2, 1))

```
```{r}

classified_forecasts <- lapply(reconstructed_forecasts, function(forecast) {
  ifelse(forecast >= 0 & forecast <= 2, 0,
         ifelse(forecast > 2 & forecast <= 5, 1, 
                ifelse(forecast > 5, 2, NA)))
})


ts_g_classified <- ifelse(ts_g >= 0 & ts_g <= 2, 0,
                                 ifelse(ts_g > 2 & ts_g <= 5, 1, 
                                        ifelse(ts_g > 5, 2, NA)))

ts_a_classified <- ifelse(ts_a >= 0 & ts_a <= 2, 0,
                                 ifelse(ts_a > 2 & ts_a <= 5, 1, 
                                        ifelse(ts_a > 5, 2, NA)))

plot(ts_g_classified)
plot(ts_a_classified)
```

